int __fastcall wavlike_read_fmt_chunk(SF_PRIVATE *psf, int fmtsize)
{
  char *container_data;
  __int16 *v4;
  int v5;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  unsigned int v8;
  const char *v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  __int16 v12;
  unsigned __int16 v13;
  __int64 v14;
  const char *v15;
  __int64 v16;
  __int64 v17;
  __int64 v18;
  __int64 v19;
  __int64 v20;
  __int64 v21;
  _WORD *v22;
  int v23;
  __int64 v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  __int64 v31;
  unsigned __int16 *v32;
  unsigned __int16 *v33;
  unsigned __int16 *v34;
  int v35;
  int v36;
  unsigned __int64 v37;
  __int64 v38;
  unsigned int v39;
  int v40;
  unsigned __int64 v41;
  __int64 v42;
  int v43;
  int v44;
  unsigned int *v45;
  int v46;
  int v47;
  int *v48;
  const char **v49;
  __int64 v50;
  int v51;
  __int64 v52;
  int v53;
  int v54;
  __int64 v55;
  const char *v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  __int64 v68;
  __int16 *v69;
  unsigned __int64 v70;
  unsigned __int16 *v71;
  int v73;
  unsigned __int16 *v74;
  unsigned __int16 *v75;
  unsigned int *v77;
  int *v78;
  int v79;
  char dest[568];

  container_data = (char *)psf->container_data;
  if ( !container_data )
    return 29;
  v4 = (__int16 *)(container_data + 12);
  memset(container_data + 12, 0, 0x200uLL);
  v5 = 65;
  if ( fmtsize >= 16 )
  {
    v6 = (unsigned __int16 *)(container_data + 14);
    v7 = (unsigned __int16 *)(container_data + 26);
    v78 = (int *)(container_data + 16);
    v77 = (unsigned int *)(container_data + 20);
    v74 = (unsigned __int16 *)(container_data + 24);
    v73 = psf_binheader_readf(psf, "224422", container_data + 12, container_data + 14);
    v8 = *((unsigned __int16 *)container_data + 6);
    v9 = wavlike_format_str(v8);
    psf_log_printf(psf, "  Format        : 0x%X => %s\n", v8, v9);
    psf_log_printf(psf, "  Channels      : %d\n", *((unsigned __int16 *)container_data + 7));
    psf_log_printf(psf, "  Sample Rate   : %d\n", *((unsigned int *)container_data + 4));
    v10 = *((_WORD *)container_data + 12);
    if ( *((_WORD *)container_data + 6) == 1 && !v10 )
    {
      if ( *v7 && *v6 )
      {
        v11 = ((*v7 >> 3) - (((*v7 & 7) == 0) - 1)) * *v6;
        *v74 = v11;
        psf_log_printf(psf, "  Block Align   : 0 (should be %d)\n", v11);
LABEL_11:
        v12 = *v4;
        v13 = *v7;
        if ( *v4 == 1 && v13 == 24 )
        {
          v14 = 24LL;
          if ( 4 * *v6 == *v74 )
          {
            psf_log_printf(psf, "  Bit Width     : 24\n", 24LL);
            psf_log_printf(
              psf,
              "\n"
              "  Ambiguous information in 'fmt ' chunk. Possibile file types:\n"
              "    0) Invalid IEEE float file generated by Syntrillium's Cooledit!\n"
              "    1) File generated by ALSA's arecord containing 24 bit samples in 32 bit containers.\n"
              "    2) 24 bit file with incorrect Block Align value.\n"
              "\n");
            *((_DWORD *)container_data + 2) = 1;
            goto LABEL_23;
          }
        }
        else
        {
          v14 = v13;
          if ( v13 )
          {
            if ( v12 == 29232 || v12 == 49 )
            {
              v15 = "  Bit Width     : %d (should be 0)\n";
LABEL_22:
              psf_log_printf(psf, v15, v14);
              goto LABEL_23;
            }
          }
          else if ( v12 != 29232 && v12 != 49 )
          {
            psf_log_printf(psf, "  Bit Width     : %d (should not be 0)\n", 0LL);
LABEL_23:
            psf->sf.samplerate = *v78;
            psf->sf.frames = 0LL;
            psf->sf.channels = *v6;
            switch ( (unsigned __int16)*(_DWORD *)v4 )
            {
              case 0xFFFE:
                v20 = *v77;
                v21 = *v78 * (unsigned int)*v74;
                if ( (_DWORD)v20 == (_DWORD)v21 )
                  psf_log_printf(psf, "  Bytes/sec     : %d\n", v20);
                else
                  psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", v20, v21);
                v45 = (unsigned int *)(container_data + 32);
                v46 = psf_binheader_readf(psf, "224", container_data + 28, container_data + 30, container_data + 32);
                psf_log_printf(psf, "  Valid Bits    : %d\n", *((unsigned __int16 *)container_data + 15));
                v47 = *((_DWORD *)container_data + 8);
                if ( !v47 )
                {
                  v75 = (unsigned __int16 *)(container_data + 14);
                  psf_log_printf(psf, "  Channel Mask  : 0x0 (should not be zero)\n");
                  v57 = v73;
                  goto LABEL_80;
                }
                *((_DWORD *)container_data + 1) = v47;
                free(psf->channel_map);
                v48 = (int *)calloc(psf->sf.channels, 4uLL);
                psf->channel_map = v48;
                if ( !v48 )
                  return 17;
                v79 = v46;
                v75 = (unsigned __int16 *)(container_data + 14);
                dest[0] = 0;
                v49 = (const char **)(channel_mask_bits + 8);
                v50 = 0LL;
                v51 = 0;
                break;
              case 1u:
              case 3u:
                v16 = *v78 * (unsigned int)*v74;
                v17 = *v77;
                if ( (_DWORD)v17 == (_DWORD)v16 )
                  psf_log_printf(psf, "  Bytes/sec     : %d\n", (unsigned int)v16);
                else
                  psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", v17, v16);
                psf->bytewidth = ((unsigned int)*v7 + 7) >> 3;
                goto LABEL_111;
              case 2u:
                v5 = 73;
                if ( *v7 != 4 )
                  return v5;
                v5 = 74;
                if ( (unsigned __int16)(*((_WORD *)container_data + 7) - 1) > 1u )
                  return v5;
                v22 = container_data + 32;
                v23 = psf_binheader_readf(psf, "222", container_data + 28, container_data + 30, container_data + 32);
                psf_log_printf(psf, "  Extra Bytes   : %d\n", *((unsigned __int16 *)container_data + 14));
                v24 = *((unsigned __int16 *)container_data + 15);
                if ( !*((_WORD *)container_data + 15) )
                  goto LABEL_84;
                psf_log_printf(psf, "  Samples/Block : %d\n", v24);
                v25 = *v74;
                v26 = *((unsigned __int16 *)container_data + 15);
                v27 = v25 * *v78 / v26;
                v28 = *v77;
                if ( *v77 == v27 )
                {
                  psf_log_printf(psf, "  Bytes/sec     : %d\n", v27);
                  v6 = (unsigned __int16 *)(container_data + 14);
                }
                else
                {
                  v6 = (unsigned __int16 *)(container_data + 14);
                  if ( v28 == v25 * (*v78 / v26) )
                    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d (MS BUG!))\n", v28, v27);
                  else
                    psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", v28, v27);
                }
                v68 = (unsigned __int16)*v22;
                if ( (unsigned int)v68 < 8 )
                {
                  psf_log_printf(psf, "  No. of Coeffs : %d\n", v68);
                }
                else
                {
                  psf_log_printf(psf, "  No. of Coeffs : %d (should be <= %d)\n", v68, 7LL);
                  *v22 = 7;
                }
                v44 = v23 + v73;
                psf_log_printf(psf, "    Index   Coeffs1   Coeffs2\n");
                if ( *v22 )
                {
                  v69 = (__int16 *)(container_data + 36);
                  v70 = 0LL;
                  do
                  {
                    v44 += psf_binheader_readf(psf, "22", v69 - 1, v69);
                    __snprintf_chk(
                      dest,
                      128LL,
                      1LL,
                      128LL,
                      "     %2d     %7d   %7d\n",
                      (unsigned int)v70,
                      (unsigned int)*(v69 - 1),
                      (unsigned int)*v69);
                    psf_log_printf(psf, dest);
                    ++v70;
                    v69 += 2;
                  }
                  while ( v70 < (unsigned __int16)*v22 );
                }
                goto LABEL_112;
              case 6u:
              case 7u:
                v18 = *v77;
                v19 = *v78 * (unsigned int)*v74;
                if ( (_DWORD)v18 == (_DWORD)v19 )
                  psf_log_printf(psf, "  Bytes/sec     : %d\n", v18);
                else
                  psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", v18, v19);
                psf->bytewidth = 1;
                v44 = v73;
                if ( fmtsize >= 18 )
                  goto LABEL_58;
                goto LABEL_112;
              case 0x11u:
                v5 = 73;
                if ( *v7 != 4 )
                  return v5;
                v5 = 74;
                if ( (unsigned __int16)(*((_WORD *)container_data + 7) - 1) > 1u )
                  return v5;
                v29 = psf_binheader_readf(psf, "22", container_data + 28, container_data + 30);
                psf_log_printf(psf, "  Extra Bytes   : %d\n", *((unsigned __int16 *)container_data + 14));
                v24 = *((unsigned __int16 *)container_data + 15);
                if ( !*((_WORD *)container_data + 15) )
                {
LABEL_84:
                  psf_log_printf(psf, "  Samples/Block : %d (should be > 0)\n", v24);
                  return 75;
                }
                v73 += v29;
                psf_log_printf(psf, "  Samples/Block : %d\n", v24);
                v30 = *v78 * (unsigned int)*v74 / *((unsigned __int16 *)container_data + 15);
                v31 = *v77;
                if ( (_DWORD)v31 == v30 )
                  psf_log_printf(psf, "  Bytes/sec     : %d\n", v30);
                else
                  psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", v31, v30);
                v6 = (unsigned __int16 *)(container_data + 14);
                goto LABEL_111;
              case 0x31u:
                v5 = 76;
                if ( *((_WORD *)container_data + 7) != 1 )
                  return v5;
                v32 = (unsigned __int16 *)(container_data + 14);
                if ( *v74 != 65 )
                  return v5;
                v33 = (unsigned __int16 *)(container_data + 28);
                v34 = (unsigned __int16 *)(container_data + 30);
                v35 = psf_binheader_readf(psf, "22", container_data + 28, container_data + 30);
                if ( *((_WORD *)container_data + 15) != 320 )
                  return v5;
                v36 = v35;
                v37 = *v78 * (unsigned int)*v74 / 0x140uLL;
                v38 = *v77;
                if ( (_DWORD)v38 == (_DWORD)v37 )
                  psf_log_printf(psf, "  Bytes/sec     : %d\n", (unsigned int)v37);
                else
                  psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", v38, v37);
                v6 = v32;
                psf_log_printf(psf, "  Extra Bytes   : %d\n", *v33);
                psf_log_printf(psf, "  Samples/Block : %d\n", *v34);
                v44 = v36 + v73;
                goto LABEL_112;
              case 0x38u:
                v5 = 79;
                if ( *((_WORD *)container_data + 7) != 1 )
                  return v5;
                v39 = *v7;
                if ( v39 < 2 )
                  return v5;
                v40 = (20 * v39) | 2;
                if ( v40 != *v74 )
                  return v5;
                v41 = (unsigned int)(*v78 * v40) / 0xA0uLL;
                v42 = *v77;
                if ( (_DWORD)v42 == (_DWORD)v41 )
                  psf_log_printf(psf, "  Bytes/sec     : %d\n", (unsigned int)v41);
                else
                  psf_log_printf(psf, "  Bytes/sec     : %d (should be %d)\n", v42, v41);
                v6 = (unsigned __int16 *)(container_data + 14);
                v44 = v73;
                if ( fmtsize >= 18 )
                {
LABEL_58:
                  v44 += psf_binheader_readf(psf, "2", container_data + 28);
                  psf_log_printf(psf, "  Extra Bytes   : %d\n", *((unsigned __int16 *)container_data + 14));
                }
                goto LABEL_112;
              case 0x40u:
                psf_log_printf(psf, "  Bytes/sec     : %d\n", *v77);
                if ( fmtsize < 20 )
                {
                  if ( fmtsize == 18 )
                  {
                    v44 = psf_binheader_readf(psf, "2", container_data + 28) + v73;
                    v56 = " (should be 0)";
                    if ( !*((_WORD *)container_data + 14) )
                      v56 = "\n"
                            "  Ambiguous information in 'fmt ' chunk. Possibile file types:\n"
                            "    0) Invalid IEEE float file generated by Syntrillium's Cooledit!\n"
                            "    1) File generated by ALSA's arecord containing 24 bit samples in 32 bit containers.\n"
                            "    2) 24 bit file with incorrect Block Align value.\n"
                            "\n"
                          + 274;
                    psf_log_printf(psf, "  Extra Bytes   : %d%s\n", *((unsigned __int16 *)container_data + 14), v56);
                  }
                  else
                  {
                    psf_log_printf(psf, "*** 'fmt ' chunk should be bigger than this!\n");
LABEL_111:
                    v44 = v73;
                  }
                }
                else
                {
                  v43 = psf_binheader_readf(psf, "22", container_data + 28, container_data + 30);
                  if ( *((_WORD *)container_data + 14) )
                    psf_log_printf(psf, "  Extra Bytes   : %d\n");
                  else
                    psf_log_printf(psf, "  Extra Bytes   : %d (should be 2)\n");
                  v44 = v43 + v73;
                  psf_log_printf(psf, "  Aux Blk Size  : %d\n", *((unsigned __int16 *)container_data + 15));
                }
LABEL_112:
                if ( v44 <= fmtsize )
                {
                  v71 = v6;
                  v5 = 0;
                  psf_binheader_readf(psf, "j", (unsigned int)(fmtsize - v44));
                  psf->blockwidth = psf->bytewidth * *v71;
                }
                else
                {
                  psf_log_printf(psf, "*** wavlike_read_fmt_chunk (bytesread > fmtsize)\n");
                  return 64;
                }
                return v5;
              default:
                psf_log_printf(psf, "*** No 'fmt ' chunk dumper for this format!\n");
                return 64;
            }
            while ( 1 )
            {
              v53 = *v45;
              if ( _bittest(&v53, v50) )
              {
                if ( v51 > psf->sf.channels )
                {
                  psf_log_printf(psf, "*** More channel map bits than there are channels.\n");
LABEL_69:
                  v54 = strlen(dest);
                  dest[v54 - 1] = 0;
                  dest[v54 - 2] = 0;
                  v55 = *v45;
                  if ( v51 == psf->sf.channels )
                  {
                    psf_log_printf(psf, "  Channel Mask  : 0x%X (%s)\n", v55, dest);
                  }
                  else
                  {
                    psf_log_printf(psf, "  Channel Mask  : 0x%X\n", v55);
                    psf_log_printf(psf, "*** Less channel map bits than there are channels.\n");
                  }
                  v57 = v73;
                  v46 = v79;
LABEL_80:
                  v58 = v57
                      + v46
                      + psf_binheader_readf(psf, "422", container_data + 36, container_data + 40, container_data + 42);
                  psf_log_printf(psf, "  Subformat\n");
                  psf_log_printf(psf, "    esf_field1 : 0x%X\n", *((unsigned int *)container_data + 9));
                  psf_log_printf(psf, "    esf_field2 : 0x%X\n", *((unsigned __int16 *)container_data + 20));
                  psf_log_printf(psf, "    esf_field3 : 0x%X\n", *((unsigned __int16 *)container_data + 21));
                  psf_log_printf(psf, "    esf_field4 : ");
                  v59 = v58 + psf_binheader_readf(psf, "1", container_data + 44);
                  psf_log_printf(psf, "0x%X ", (unsigned __int8)container_data[44]);
                  v60 = v59 + psf_binheader_readf(psf, "1", container_data + 45);
                  psf_log_printf(psf, "0x%X ", (unsigned __int8)container_data[45]);
                  v61 = v60 + psf_binheader_readf(psf, "1", container_data + 46);
                  psf_log_printf(psf, "0x%X ", (unsigned __int8)container_data[46]);
                  v62 = v61 + psf_binheader_readf(psf, "1", container_data + 47);
                  psf_log_printf(psf, "0x%X ", (unsigned __int8)container_data[47]);
                  v63 = v62 + psf_binheader_readf(psf, "1", container_data + 48);
                  psf_log_printf(psf, "0x%X ", (unsigned __int8)container_data[48]);
                  v64 = v63 + psf_binheader_readf(psf, "1", container_data + 49);
                  psf_log_printf(psf, "0x%X ", (unsigned __int8)container_data[49]);
                  v65 = v64 + psf_binheader_readf(psf, "1", container_data + 50);
                  psf_log_printf(psf, "0x%X ", (unsigned __int8)container_data[50]);
                  v73 = v65 + psf_binheader_readf(psf, "1", container_data + 51);
                  psf_log_printf(psf, "0x%X ", (unsigned __int8)container_data[51]);
                  psf_log_printf(psf, "\n");
                  v66 = *((unsigned __int16 *)container_data + 13) + 7;
                  v67 = v66 >> 3;
                  psf->bytewidth = v66 >> 3;
                  if ( wavex_guid_equal((const EXT_SUBFORMAT *)(container_data + 36), &MSGUID_SUBTYPE_PCM) )
                  {
                    psf->sf.format = u_bitwidth_to_subformat(v66 & 0xFFFFFFF8) | 0x130000;
                    psf_log_printf(psf, "    format : pcm\n");
                    v6 = v75;
                    goto LABEL_111;
                  }
                  v6 = v75;
                  if ( wavex_guid_equal((const EXT_SUBFORMAT *)(container_data + 36), &MSGUID_SUBTYPE_MS_ADPCM) )
                  {
                    psf->sf.format = 1245203;
                    psf_log_printf(psf, "    format : ms adpcm\n");
                    goto LABEL_111;
                  }
                  if ( wavex_guid_equal((const EXT_SUBFORMAT *)(container_data + 36), &MSGUID_SUBTYPE_IEEE_FLOAT) )
                  {
                    psf->sf.format = (v67 == 8) | 0x130006;
                    psf_log_printf(psf, "    format : IEEE float\n");
                    goto LABEL_111;
                  }
                  if ( wavex_guid_equal((const EXT_SUBFORMAT *)(container_data + 36), &MSGUID_SUBTYPE_ALAW) )
                  {
                    psf->sf.format = 1245201;
                    psf_log_printf(psf, "    format : A-law\n");
                    goto LABEL_111;
                  }
                  if ( wavex_guid_equal((const EXT_SUBFORMAT *)(container_data + 36), &MSGUID_SUBTYPE_MULAW) )
                  {
                    psf->sf.format = 1245200;
                    psf_log_printf(psf, "    format : u-law\n");
                    goto LABEL_111;
                  }
                  if ( wavex_guid_equal(
                         (const EXT_SUBFORMAT *)(container_data + 36),
                         &MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_PCM) )
                  {
                    psf->sf.format = u_bitwidth_to_subformat(v66 & 0xFFFFFFF8) | 0x130000;
                    psf_log_printf(psf, "    format : pcm (Ambisonic B)\n");
LABEL_121:
                    *(_DWORD *)container_data = 65;
                    goto LABEL_111;
                  }
                  if ( wavex_guid_equal(
                         (const EXT_SUBFORMAT *)(container_data + 36),
                         &MSGUID_SUBTYPE_AMBISONIC_B_FORMAT_IEEE_FLOAT) )
                  {
                    psf->sf.format = (v67 == 8) | 0x130006;
                    psf_log_printf(psf, "    format : IEEE float (Ambisonic B)\n");
                    goto LABEL_121;
                  }
                  return 18;
                }
                v52 = v51++;
                psf->channel_map[v52] = *((_DWORD *)v49 - 2);
                append_snprintf(dest, 0x200uLL, "%s, ", *v49);
              }
              ++v50;
              v49 += 2;
              if ( v50 == 18 )
                goto LABEL_69;
            }
          }
        }
        v15 = "  Bit Width     : %d\n";
        goto LABEL_22;
      }
      v10 = 0;
    }
    psf_log_printf(psf, "  Block Align   : %d\n", v10);
    goto LABEL_11;
  }
  return v5;
}
